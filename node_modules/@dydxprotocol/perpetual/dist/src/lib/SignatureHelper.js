"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var web3_1 = __importDefault(require("web3"));
var BytesHelper_1 = require("./BytesHelper");
var SIGNATURE_TYPES;
(function (SIGNATURE_TYPES) {
    SIGNATURE_TYPES[SIGNATURE_TYPES["NO_PREPEND"] = 0] = "NO_PREPEND";
    SIGNATURE_TYPES[SIGNATURE_TYPES["DECIMAL"] = 1] = "DECIMAL";
    SIGNATURE_TYPES[SIGNATURE_TYPES["HEXADECIMAL"] = 2] = "HEXADECIMAL";
})(SIGNATURE_TYPES = exports.SIGNATURE_TYPES || (exports.SIGNATURE_TYPES = {}));
exports.PREPEND_DEC = '\x19Ethereum Signed Message:\n32';
exports.PREPEND_HEX = '\x19Ethereum Signed Message:\n\x20';
exports.EIP712_DOMAIN_STRING = 'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)';
exports.EIP712_DOMAIN_STRUCT = [
    { name: 'name', type: 'string' },
    { name: 'version', type: 'string' },
    { name: 'chainId', type: 'uint256' },
    { name: 'verifyingContract', type: 'address' },
];
function isValidSigType(sigType) {
    switch (sigType) {
        case SIGNATURE_TYPES.NO_PREPEND:
        case SIGNATURE_TYPES.DECIMAL:
        case SIGNATURE_TYPES.HEXADECIMAL:
            return true;
        default:
            return false;
    }
}
exports.isValidSigType = isValidSigType;
function getPrependedHash(hash, sigType) {
    switch (sigType) {
        case SIGNATURE_TYPES.NO_PREPEND:
            return hash;
        case SIGNATURE_TYPES.DECIMAL:
            return web3_1.default.utils.soliditySha3({ t: 'string', v: exports.PREPEND_DEC }, { t: 'bytes32', v: hash });
        case SIGNATURE_TYPES.HEXADECIMAL:
            return web3_1.default.utils.soliditySha3({ t: 'string', v: exports.PREPEND_HEX }, { t: 'bytes32', v: hash });
        default:
            throw Error("invalid sigType " + sigType);
    }
}
exports.getPrependedHash = getPrependedHash;
function ecRecoverTypedSignature(hash, typedSignature) {
    if (BytesHelper_1.stripHexPrefix(typedSignature).length !== 66 * 2) {
        return '0x'; // return invalid address instead of throwing error
    }
    var sigType = parseInt(typedSignature.slice(-2), 16);
    var prependedHash;
    try {
        prependedHash = getPrependedHash(hash, sigType);
    }
    catch (e) {
        return '0x'; // return invalid address instead of throwing error
    }
    var signature = typedSignature.slice(0, -2);
    return new web3_1.default().eth.accounts.recover(prependedHash, signature, true);
}
exports.ecRecoverTypedSignature = ecRecoverTypedSignature;
function createTypedSignature(signature, sigType) {
    if (!isValidSigType(sigType)) {
        throw new Error("Invalid signature type: " + sigType);
    }
    return fixRawSignature(signature) + "0" + sigType;
}
exports.createTypedSignature = createTypedSignature;
/**
 * Fixes any signatures that don't have a 'v' value of 27 or 28
 */
function fixRawSignature(signature) {
    var _a = signatureToVRS(signature), v = _a.v, r = _a.r, s = _a.s;
    var trueV;
    switch (v) {
        case '00':
            trueV = '1b';
            break;
        case '01':
            trueV = '1c';
            break;
        case '1b':
        case '1c':
            trueV = v;
            break;
        default:
            throw new Error("Invalid v value: " + v);
    }
    return BytesHelper_1.combineHexStrings(r, s, trueV);
}
exports.fixRawSignature = fixRawSignature;
function signatureToVRS(signature) {
    var stripped = BytesHelper_1.stripHexPrefix(signature);
    if (stripped.length !== 130) {
        throw new Error("Invalid raw signature: " + signature);
    }
    var r = stripped.substr(0, 64);
    var s = stripped.substr(64, 64);
    var v = stripped.substr(128, 2);
    return { v: v, r: r, s: s };
}
exports.signatureToVRS = signatureToVRS;
//# sourceMappingURL=SignatureHelper.js.map