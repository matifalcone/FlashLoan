import BigNumber from 'bignumber.js';
import { HttpProvider, IpcProvider, WebsocketProvider, Log, EventLog } from 'web3-core';
import { TransactionReceipt } from 'web3-eth';
export declare type address = string;
export declare type TypedSignature = string;
export declare type Provider = HttpProvider | IpcProvider | WebsocketProvider;
export declare type BigNumberable = BigNumber | number | string;
export declare enum ConfirmationType {
    Hash = 0,
    Confirmed = 1,
    Both = 2,
    Simulate = 3
}
export declare enum SigningMethod {
    Compatibility = "Compatibility",
    UnsafeHash = "UnsafeHash",
    Hash = "Hash",
    TypedData = "TypedData",
    MetaMask = "MetaMask",
    MetaMaskLatest = "MetaMaskLatest",
    CoinbaseWallet = "CoinbaseWallet"
}
export declare enum OrderStatus {
    Null = 0,
    Approved = 1,
    Canceled = 2
}
export interface OrderState {
    status: OrderStatus;
    filledAmount: BigNumber;
}
export declare const Networks: {
    MAINNET: number;
    KOVAN: number;
};
export interface PerpetualOptions {
    defaultAccount?: address;
    sendOptions?: SendOptions;
    apiOptions?: ApiOptions;
    accounts?: EthereumAccount[];
}
export interface ApiOptions {
    endpoint?: string;
    timeout?: number;
}
export interface EthereumAccount {
    address?: string;
    privateKey: string;
}
export interface TxResult {
    transactionHash?: string;
    transactionIndex?: number;
    blockHash?: string;
    blockNumber?: number;
    from?: string;
    to?: string;
    contractAddress?: string;
    cumulativeGasUsed?: number;
    gasUsed?: number;
    logs?: Log[];
    events?: {
        [eventName: string]: EventLog;
    };
    status?: boolean;
    confirmation?: Promise<TransactionReceipt>;
    gasEstimate?: number;
    gas?: number;
}
export interface TxOptions {
    from?: address;
    gasPrice?: number;
    gas?: number;
    value?: number;
}
export interface SendOptions extends TxOptions {
    confirmations?: number;
    confirmationType?: ConfirmationType;
    gasMultiplier?: number;
}
export interface CallOptions extends TxOptions {
    blockNumber?: number;
}
export interface PosAndNegValues {
    positiveValue: BigNumber;
    negativeValue: BigNumber;
}
export interface SignedIntStruct {
    value: string;
    isPositive: boolean;
}
export interface BalanceStruct {
    marginIsPositive: boolean;
    positionIsPositive: boolean;
    margin: string;
    position: string;
}
export interface FundingRateStruct {
    timestamp: BigNumber;
    isPositive: boolean;
    value: BigNumber;
}
export interface TradeArg {
    makerIndex: number;
    takerIndex: number;
    trader: address;
    data: string;
}
export interface TradeResult {
    marginAmount: BigNumber;
    positionAmount: BigNumber;
    isBuy: boolean;
    traderFlags: BigNumber;
}
export interface FundingRateBounds {
    maxAbsValue: FundingRate;
    maxAbsDiffPerUpdate: FundingRate;
    maxAbsDiffPerSecond: FundingRate;
}
export interface LoggedFundingRate {
    timestamp: BigNumber;
    baseValue: BaseValue;
}
export interface Index {
    timestamp: BigNumber;
    baseValue: BaseValue;
}
export interface Order {
    isBuy: boolean;
    isDecreaseOnly: boolean;
    amount: BigNumber;
    limitPrice: Price;
    triggerPrice: Price;
    limitFee: Fee;
    maker: address;
    taker: address;
    expiration: BigNumber;
    salt: BigNumber;
}
export interface SignedOrder extends Order {
    typedSignature: string;
}
export interface MakerOracleMessage {
    price: Price;
    timestamp: BigNumber;
    signature: string;
}
export declare function bnToSoliditySignedInt(value: BigNumberable): SignedIntStruct;
export declare function bnFromSoliditySignedInt(struct: SignedIntStruct): BigNumber;
export declare class Balance {
    margin: BigNumber;
    position: BigNumber;
    constructor(margin: BigNumberable, position: BigNumberable);
    static fromSolidity(struct: BalanceStruct): Balance;
    toSolidity(): BalanceStruct;
    copy(): Balance;
    /**
     * Get the positive and negative values (in terms of margin-token) of the balance,
     * given an oracle price.
     */
    getPositiveAndNegativeValues(price: Price): PosAndNegValues;
    /**
     * Get the collateralization ratio of the balance, given an oracle price.
     *
     * Returns BigNumber(Infinity) if there are no negative balances.
     */
    getCollateralization(price: Price): BigNumber;
}
export declare const BASE_DECIMALS = 18;
/**
 * A value that is represented on the smart contract by an integer shifted by `BASE` decimal places.
 */
export declare class BaseValue {
    readonly value: BigNumber;
    constructor(value: BigNumberable);
    toSolidity(): string;
    toSoliditySignedInt(): SignedIntStruct;
    static fromSolidity(solidityValue: BigNumberable, isPositive?: boolean): BaseValue;
    /**
     * Return the BaseValue, rounded down to the nearest Solidity-representable value.
     */
    roundedDown(): BaseValue;
    times(value: BigNumberable): BaseValue;
    div(value: BigNumberable): BaseValue;
    plus(value: BigNumberable): BaseValue;
    minus(value: BigNumberable): BaseValue;
    negated(): BaseValue;
    isPositive(): boolean;
    isNegative(): boolean;
}
export declare class Price extends BaseValue {
}
export declare class Fee extends BaseValue {
    static fromBips(value: BigNumberable): Fee;
}
export declare class FundingRate extends BaseValue {
    /**
     * Given a daily rate, returns funding rate represented as a per-second rate.
     *
     * Note: Funding interest does not compound, as the interest affects margin balances but
     * is calculated based on position balances.
     */
    static fromEightHourRate(rate: BigNumberable): FundingRate;
}
export declare enum ApiOrderStatus {
    PENDING = "PENDING",
    OPEN = "OPEN",
    FILLED = "FILLED",
    PARTIALLY_FILLED = "PARTIALLY_FILLED",
    CANCELED = "CANCELED",
    UNTRIGGERED = "UNTRIGGERED"
}
export declare enum ApiOrderType {
    PERPETUAL_CROSS = "PERPETUAL_CROSS",
    PERPETUAL_STOP_LIMIT = "PERPETUAL_STOP_LIMIT"
}
export declare enum ApiMarketName {
    PBTC_USDC = "PBTC-USDC"
}
export declare enum ApiSide {
    BUY = "BUY",
    SELL = "SELL"
}
export declare enum ApiOrderCancelReason {
    EXPIRED = "EXPIRED",
    UNDERCOLLATERALIZED = "UNDERCOLLATERALIZED",
    CANCELED_ON_CHAIN = "CANCELED_ON_CHAIN",
    USER_CANCELED = "USER_CANCELED",
    SELF_TRADE = "SELF_TRADE",
    FAILED = "FAILED",
    COULD_NOT_FILL = "COULD_NOT_FILL",
    POST_ONLY_WOULD_CROSS = "POST_ONLY_WOULD_CROSS"
}
export interface ApiOrder {
    uuid: string;
    id: string;
    status: ApiOrderStatus;
    accountOwner: string;
    accountNumber: string;
    orderType: ApiOrderType;
    fillOrKill: boolean;
    market: ApiMarketName;
    side: ApiSide;
    baseAmount: string;
    quoteAmount: string;
    filledAmount: string;
    price: string;
    cancelReason: ApiOrderCancelReason;
}
export interface ApiOrderOnOrderbook {
    id: string;
    uuid: string;
    amount: string;
    price: string;
}
export interface ApiBalance {
    margin: string;
    position: string;
    indexValue: string;
    indexTimestamp: string;
    pendingMargin: string;
    pendingPosition: string;
}
export interface ApiMarketMessage {
    createdAt: string;
    updatedAt: string;
    market: ApiMarketName;
    oraclePrice: string;
    fundingRate: string;
    globalIndexValue: string;
    globalIndexTimeStamp: string;
}
export interface ApiAccount {
    owner: string;
    uuid: string;
    balances: {
        [market: string]: ApiBalance;
    };
}
