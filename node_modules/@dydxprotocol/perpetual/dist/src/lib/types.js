"use strict";
/*

    Copyright 2020 dYdX Trading Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = __importDefault(require("bignumber.js"));
// ============ Enums ============
var ConfirmationType;
(function (ConfirmationType) {
    ConfirmationType[ConfirmationType["Hash"] = 0] = "Hash";
    ConfirmationType[ConfirmationType["Confirmed"] = 1] = "Confirmed";
    ConfirmationType[ConfirmationType["Both"] = 2] = "Both";
    ConfirmationType[ConfirmationType["Simulate"] = 3] = "Simulate";
})(ConfirmationType = exports.ConfirmationType || (exports.ConfirmationType = {}));
var SigningMethod;
(function (SigningMethod) {
    SigningMethod["Compatibility"] = "Compatibility";
    SigningMethod["UnsafeHash"] = "UnsafeHash";
    SigningMethod["Hash"] = "Hash";
    SigningMethod["TypedData"] = "TypedData";
    SigningMethod["MetaMask"] = "MetaMask";
    SigningMethod["MetaMaskLatest"] = "MetaMaskLatest";
    SigningMethod["CoinbaseWallet"] = "CoinbaseWallet";
})(SigningMethod = exports.SigningMethod || (exports.SigningMethod = {}));
var OrderStatus;
(function (OrderStatus) {
    OrderStatus[OrderStatus["Null"] = 0] = "Null";
    OrderStatus[OrderStatus["Approved"] = 1] = "Approved";
    OrderStatus[OrderStatus["Canceled"] = 2] = "Canceled";
})(OrderStatus = exports.OrderStatus || (exports.OrderStatus = {}));
// ============ Constants ============
exports.Networks = {
    MAINNET: 1,
    KOVAN: 42,
};
// ============ Helper Functions ============
function bnToSoliditySignedInt(value) {
    var bn = new bignumber_js_1.default(value);
    return {
        value: bn.abs().toFixed(0),
        isPositive: bn.isPositive(),
    };
}
exports.bnToSoliditySignedInt = bnToSoliditySignedInt;
function bnFromSoliditySignedInt(struct) {
    if (struct.isPositive) {
        return new bignumber_js_1.default(struct.value);
    }
    return new bignumber_js_1.default(struct.value).negated();
}
exports.bnFromSoliditySignedInt = bnFromSoliditySignedInt;
// ============ Classes ============
var Balance = /** @class */ (function () {
    function Balance(margin, position) {
        this.margin = new bignumber_js_1.default(margin);
        this.position = new bignumber_js_1.default(position);
    }
    Balance.fromSolidity = function (struct) {
        var marginBN = new bignumber_js_1.default(struct.margin);
        var positionBN = new bignumber_js_1.default(struct.position);
        return new Balance(struct.marginIsPositive ? marginBN : marginBN.negated(), struct.positionIsPositive ? positionBN : positionBN.negated());
    };
    Balance.prototype.toSolidity = function () {
        return {
            marginIsPositive: this.margin.isPositive(),
            positionIsPositive: this.position.isPositive(),
            margin: this.margin.abs().toFixed(0),
            position: this.position.abs().toFixed(0),
        };
    };
    Balance.prototype.copy = function () {
        return new Balance(this.margin, this.position);
    };
    /**
     * Get the positive and negative values (in terms of margin-token) of the balance,
     * given an oracle price.
     */
    Balance.prototype.getPositiveAndNegativeValues = function (price) {
        var positiveValue = new bignumber_js_1.default(0);
        var negativeValue = new bignumber_js_1.default(0);
        var marginValue = this.margin.abs();
        if (this.margin.isPositive()) {
            positiveValue = marginValue;
        }
        else {
            negativeValue = marginValue;
        }
        var positionValue = this.position.times(price.value).abs();
        if (this.position.isPositive()) {
            positiveValue = positiveValue.plus(positionValue);
        }
        else {
            negativeValue = negativeValue.plus(positionValue);
        }
        return { positiveValue: positiveValue, negativeValue: negativeValue };
    };
    /**
     * Get the collateralization ratio of the balance, given an oracle price.
     *
     * Returns BigNumber(Infinity) if there are no negative balances.
     */
    Balance.prototype.getCollateralization = function (price) {
        var values = this.getPositiveAndNegativeValues(price);
        if (values.negativeValue.isZero()) {
            return new bignumber_js_1.default(Infinity);
        }
        return values.positiveValue.div(values.negativeValue);
    };
    return Balance;
}());
exports.Balance = Balance;
// From BaseMath.sol.
exports.BASE_DECIMALS = 18;
/**
 * A value that is represented on the smart contract by an integer shifted by `BASE` decimal places.
 */
var BaseValue = /** @class */ (function () {
    function BaseValue(value) {
        this.value = new bignumber_js_1.default(value);
    }
    BaseValue.prototype.toSolidity = function () {
        return this.value.abs().shiftedBy(exports.BASE_DECIMALS).toFixed(0);
    };
    BaseValue.prototype.toSoliditySignedInt = function () {
        return {
            value: this.toSolidity(),
            isPositive: this.isPositive(),
        };
    };
    BaseValue.fromSolidity = function (solidityValue, isPositive) {
        if (isPositive === void 0) { isPositive = true; }
        // Help to detect errors in the parsing and typing of Solidity data.
        if (typeof isPositive !== 'boolean') {
            throw new Error('Error in BaseValue.fromSolidity: isPositive was not a boolean');
        }
        var value = new bignumber_js_1.default(solidityValue).shiftedBy(-exports.BASE_DECIMALS);
        if (!isPositive) {
            value = value.negated();
        }
        return new BaseValue(value);
    };
    /**
     * Return the BaseValue, rounded down to the nearest Solidity-representable value.
     */
    BaseValue.prototype.roundedDown = function () {
        return new BaseValue(this.value.decimalPlaces(exports.BASE_DECIMALS, bignumber_js_1.default.ROUND_DOWN));
    };
    BaseValue.prototype.times = function (value) {
        return new BaseValue(this.value.times(value));
    };
    BaseValue.prototype.div = function (value) {
        return new BaseValue(this.value.div(value));
    };
    BaseValue.prototype.plus = function (value) {
        return new BaseValue(this.value.plus(value));
    };
    BaseValue.prototype.minus = function (value) {
        return new BaseValue(this.value.minus(value));
    };
    BaseValue.prototype.negated = function () {
        return new BaseValue(this.value.negated());
    };
    BaseValue.prototype.isPositive = function () {
        return this.value.isPositive();
    };
    BaseValue.prototype.isNegative = function () {
        return this.value.isNegative();
    };
    return BaseValue;
}());
exports.BaseValue = BaseValue;
var Price = /** @class */ (function (_super) {
    __extends(Price, _super);
    function Price() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Price;
}(BaseValue));
exports.Price = Price;
var Fee = /** @class */ (function (_super) {
    __extends(Fee, _super);
    function Fee() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Fee.fromBips = function (value) {
        return new Fee(new bignumber_js_1.default('1e-4').times(value));
    };
    return Fee;
}(BaseValue));
exports.Fee = Fee;
var FundingRate = /** @class */ (function (_super) {
    __extends(FundingRate, _super);
    function FundingRate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Given a daily rate, returns funding rate represented as a per-second rate.
     *
     * Note: Funding interest does not compound, as the interest affects margin balances but
     * is calculated based on position balances.
     */
    FundingRate.fromEightHourRate = function (rate) {
        return new FundingRate(new bignumber_js_1.default(rate).div(8 * 60 * 60));
    };
    return FundingRate;
}(BaseValue));
exports.FundingRate = FundingRate;
var ApiOrderStatus;
(function (ApiOrderStatus) {
    ApiOrderStatus["PENDING"] = "PENDING";
    ApiOrderStatus["OPEN"] = "OPEN";
    ApiOrderStatus["FILLED"] = "FILLED";
    ApiOrderStatus["PARTIALLY_FILLED"] = "PARTIALLY_FILLED";
    ApiOrderStatus["CANCELED"] = "CANCELED";
    ApiOrderStatus["UNTRIGGERED"] = "UNTRIGGERED";
})(ApiOrderStatus = exports.ApiOrderStatus || (exports.ApiOrderStatus = {}));
var ApiOrderType;
(function (ApiOrderType) {
    ApiOrderType["PERPETUAL_CROSS"] = "PERPETUAL_CROSS";
    ApiOrderType["PERPETUAL_STOP_LIMIT"] = "PERPETUAL_STOP_LIMIT";
})(ApiOrderType = exports.ApiOrderType || (exports.ApiOrderType = {}));
var ApiMarketName;
(function (ApiMarketName) {
    ApiMarketName["PBTC_USDC"] = "PBTC-USDC";
})(ApiMarketName = exports.ApiMarketName || (exports.ApiMarketName = {}));
var ApiSide;
(function (ApiSide) {
    ApiSide["BUY"] = "BUY";
    ApiSide["SELL"] = "SELL";
})(ApiSide = exports.ApiSide || (exports.ApiSide = {}));
var ApiOrderCancelReason;
(function (ApiOrderCancelReason) {
    ApiOrderCancelReason["EXPIRED"] = "EXPIRED";
    ApiOrderCancelReason["UNDERCOLLATERALIZED"] = "UNDERCOLLATERALIZED";
    ApiOrderCancelReason["CANCELED_ON_CHAIN"] = "CANCELED_ON_CHAIN";
    ApiOrderCancelReason["USER_CANCELED"] = "USER_CANCELED";
    ApiOrderCancelReason["SELF_TRADE"] = "SELF_TRADE";
    ApiOrderCancelReason["FAILED"] = "FAILED";
    ApiOrderCancelReason["COULD_NOT_FILL"] = "COULD_NOT_FILL";
    ApiOrderCancelReason["POST_ONLY_WOULD_CROSS"] = "POST_ONLY_WOULD_CROSS";
})(ApiOrderCancelReason = exports.ApiOrderCancelReason || (exports.ApiOrderCancelReason = {}));
//# sourceMappingURL=types.js.map