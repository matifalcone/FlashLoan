import Web3 from 'web3';
import BigNumber from 'bignumber.js';
import { Contracts } from './Contracts';
import { Balance, CallOptions, Fee, Order, OrderState, Price, SendOptions, SignedOrder, SigningMethod, address } from '../lib/types';
export declare class Orders {
    private contracts;
    private networkId;
    private web3;
    constructor(contracts: Contracts, web3: Web3, networkId: number);
    /**
     * Sends an transaction to pre-approve an order on-chain (so that no signature is required when
     * filling the order).
     */
    approveOrder(order: Order, options?: SendOptions): Promise<any>;
    /**
     * Sends an transaction to cancel an order on-chain.
     */
    cancelOrder(order: Order, options?: SendOptions): Promise<any>;
    /**
     * Gets the status and the current filled amount (in makerAmount) of all given orders.
     */
    getOrdersStatus(orders: Order[], options?: CallOptions): Promise<OrderState[]>;
    /**
     * Estimate the maker's collateralization after executing a sequence of orders.
     *
     * The `maker` of every order must be the same. This function does not make any on-chain calls,
     * so all information must be passed in, including the oracle price and remaining amounts
     * on the orders. Orders are assumed to be filled at the limit price and limit fee.
     *
     * Returns the ending collateralization ratio for the account, or BigNumber(Infinity) if the
     * account does not end with any negative balances.
     *
     * @param  initialBalance  The initial margin and position balances of the maker account.
     * @param  oraclePrice     The price at which to calculate collateralization.
     * @param  orders          A sequence of orders, with the same maker, to be hypothetically filled.
     * @param  fillAmounts     The corresponding fill amount for each order, denominated in the token
     *                         spent by the maker--quote currency when buying, and base when selling.
     */
    getAccountCollateralizationAfterMakingOrders(initialBalance: Balance, oraclePrice: Price, orders: Order[], makerTokenFillAmounts: BigNumber[]): BigNumber;
    getFeeForOrder(amount: BigNumber, isTaker?: boolean): Fee;
    getSignedOrder(order: Order, signingMethod: SigningMethod): Promise<SignedOrder>;
    /**
     * Sends order to current provider for signing. Can sign locally if the signing account is
     * loaded into web3 and SigningMethod.Hash is used.
     */
    signOrder(order: Order, signingMethod: SigningMethod): Promise<string>;
    /**
     * Sends order to current provider for signing of a cancel message. Can sign locally if the
     * signing account is loaded into web3 and SigningMethod.Hash is used.
     */
    signCancelOrder(order: Order, signingMethod: SigningMethod): Promise<string>;
    /**
     * Sends orderHash to current provider for signing of a cancel message. Can sign locally if
     * the signing account is loaded into web3 and SigningMethod.Hash is used.
     */
    signCancelOrderByHash(orderHash: string, signer: string, signingMethod: SigningMethod): Promise<string>;
    /**
     * Returns true if the order object has a non-null valid signature from the maker of the order.
     */
    orderHasValidSignature(order: SignedOrder): boolean;
    /**
     * Returns true if the order hash has a non-null valid signature from a particular signer.
     */
    orderByHashHasValidSignature(orderHash: string, typedSignature: string, expectedSigner: address): boolean;
    /**
     * Returns true if the cancel order message has a valid signature.
     */
    cancelOrderHasValidSignature(order: Order, typedSignature: string): boolean;
    /**
     * Returns true if the cancel order message has a valid signature.
     */
    cancelOrderByHashHasValidSignature(orderHash: string, typedSignature: string, expectedSigner: address): boolean;
    /**
     * Returns the final signable EIP712 hash for approving an order.
     */
    getOrderHash(order: Order): string;
    /**
     * Given some order hash, returns the hash of a cancel-order message.
     */
    orderHashToCancelOrderHash(orderHash: string): string;
    /**
     * Returns the EIP712 domain separator hash.
     */
    getDomainHash(): string;
    /**
     * Returns a signable EIP712 Hash of a struct
     */
    getEIP712Hash(structHash: string): string;
    orderToBytes(order: Order): string;
    fillToTradeData(order: SignedOrder, amount: BigNumber, price: Price, fee: Fee): string;
    private orderToSolidity;
    private getDomainData;
    private ethSignTypedOrderInternal;
    private ethSignTypedCancelOrderInternal;
    private ethSignTypedDataInternal;
    private getOrderFlags;
}
