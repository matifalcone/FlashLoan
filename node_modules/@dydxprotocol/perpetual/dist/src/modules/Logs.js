"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = __importDefault(require("lodash"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var types_1 = require("../lib/types");
var Constants_1 = require("../lib/Constants");
var BytesHelper_1 = require("../lib/BytesHelper");
var TUPLE_MAP = {
    'struct P1Orders.Fill': ['amount', 'price', 'fee', 'isNegativeFee'],
};
var OLD_LIQUIDATION_ADDRESS = '0x1F8b4f89a5b8CA0BAa0eDbd0d928DD68B3357280';
var Logs = /** @class */ (function () {
    function Logs(contracts, web3) {
        this.contracts = contracts;
        this.web3 = web3;
    }
    Object.defineProperty(Logs.prototype, "contractsByAddress", {
        get: function () {
            var e_1, _a;
            if (!this._contractsByAddress) {
                this._contractsByAddress = {};
                try {
                    for (var _b = __values(this.contracts.contractsList), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var _d = _c.value, contract = _d.contract, isTest = _d.isTest;
                        if (isTest) {
                            continue; // ignore test contracts
                        }
                        if (!contract.options.address) {
                            throw new Error('Contract has not been deployed');
                        }
                        this._contractsByAddress[contract.options.address.toLowerCase()] = contract;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return this._contractsByAddress;
        },
        enumerable: true,
        configurable: true
    });
    Logs.prototype.parseLogs = function (receipt) {
        var _this = this;
        var events;
        if (receipt.logs) {
            events = JSON.parse(JSON.stringify(receipt.logs));
            return events.map(function (e) { return _this.parseLog(e); }).filter(function (l) { return !!l; });
        }
        if (receipt.events) {
            var tempEvents = JSON.parse(JSON.stringify(receipt.events));
            events = [];
            Object.values(tempEvents).forEach(function (e) {
                if (Array.isArray(e)) {
                    e.forEach(function (ev) { return events.push(ev); });
                }
                else {
                    events.push(e);
                }
            });
            events.sort(function (a, b) { return a.logIndex - b.logIndex; });
            return events.map(function (e) { return _this.parseEvent(e); }).filter(function (l) { return !!l; });
        }
        throw new Error('Receipt has no logs');
    };
    Logs.prototype.parseEvent = function (event) {
        return this.parseLog({
            address: event.address,
            data: event.raw.data,
            topics: event.raw.topics,
            logIndex: event.logIndex,
            transactionHash: event.transactionHash,
            transactionIndex: event.transactionIndex,
            blockHash: event.blockHash,
            blockNumber: event.blockNumber,
        });
    };
    Logs.prototype.parseLog = function (log) {
        var logAddress = log.address.toLowerCase();
        // Check if the logs are coming from the proxy ABI.
        if (BytesHelper_1.addressesAreEqual(logAddress, this.contracts.perpetualProxy.options.address)) {
            var parsedLog = this.parseLogWithContract(this.contracts.perpetualProxy, log);
            if (parsedLog) {
                return parsedLog;
            }
        }
        // Check if the logs are coming from the proxy ABI.
        if (BytesHelper_1.addressesAreEqual(logAddress, OLD_LIQUIDATION_ADDRESS)) {
            var parsedLog = this.parseLogWithContract(this.contracts.p1Liquidation, log);
            if (parsedLog) {
                return parsedLog;
            }
        }
        if (logAddress in this.contractsByAddress) {
            return this.parseLogWithContract(this.contractsByAddress[logAddress], log);
        }
        return null;
    };
    Logs.prototype.parseLogWithContract = function (contract, log) {
        var events = contract.options.jsonInterface.filter(function (e) { return e.type === 'event'; });
        var eventJson = events.find(function (e) { return e.signature.toLowerCase() === log.topics[0].toLowerCase(); });
        if (!eventJson) {
            return null;
        }
        var eventArgs = this.web3.eth.abi.decodeLog(eventJson.inputs, log.data, log.topics.slice(1));
        return __assign(__assign({}, log), { name: eventJson.name, args: this.parseArgs(eventJson.inputs, eventArgs) });
    };
    Logs.prototype.parseArgs = function (inputs, eventArgs) {
        var e_2, _a;
        var parsedObject = {};
        try {
            for (var inputs_1 = __values(inputs), inputs_1_1 = inputs_1.next(); !inputs_1_1.done; inputs_1_1 = inputs_1.next()) {
                var input = inputs_1_1.value;
                var name_1 = input.name;
                parsedObject[name_1] = this.parseValue(input, eventArgs[name_1]);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (inputs_1_1 && !inputs_1_1.done && (_a = inputs_1.return)) _a.call(inputs_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return parsedObject;
    };
    Logs.prototype.parseValue = function (input, argValue) {
        if (input.type === 'bytes32') {
            switch (input.name) {
                case 'balance':
                case 'makerBalance':
                case 'takerBalance':
                    return this.parseBalance(argValue);
                case 'index':
                    return this.parseIndex(argValue);
                case 'flags':
                    return this.parseOrderFlags(argValue);
                case 'fundingRate':
                    return this.parseFundingRate(argValue);
            }
        }
        if (input.type === 'uint256') {
            switch (input.name) {
                case 'fee':
                    return types_1.Fee.fromSolidity(argValue);
                case 'price':
                case 'oraclePrice':
                case 'settlementPrice':
                case 'triggerPrice':
                    return types_1.Price.fromSolidity(argValue);
            }
        }
        if (input.type === 'address') {
            return argValue;
        }
        if (input.type === 'bool') {
            return argValue;
        }
        if (input.type.match(/^bytes[0-9]*$/)) {
            return argValue;
        }
        if (input.type.match(/^uint[0-9]*$/)) {
            return new bignumber_js_1.default(argValue);
        }
        if (input.type === 'tuple') {
            return this.parseTuple(input, argValue);
        }
        throw new Error("Unknown event arg type " + input.type);
    };
    Logs.prototype.parseTuple = function (input, argValue) {
        var internalType = input.internalType;
        if (!(internalType in TUPLE_MAP)) {
            throw new Error("Unknown tuple type '" + internalType + "' in event");
        }
        var expectedTupleArgs = TUPLE_MAP[internalType];
        var actualTupleArgs = lodash_1.default.map(input.components, 'name');
        if (!lodash_1.default.isEqual(expectedTupleArgs, actualTupleArgs)) {
            throw new Error("Arg name mismatch for tuple " + internalType);
        }
        return this.parseArgs(input.components, argValue);
    };
    Logs.prototype.parseBalance = function (balance) {
        var margin = new bignumber_js_1.default(balance.substr(4, 30), 16);
        var position = new bignumber_js_1.default(balance.substr(36, 30), 16);
        var marginIsPositive = !new bignumber_js_1.default(balance.substr(2, 2), 16).isZero();
        var positionIsPositive = !new bignumber_js_1.default(balance.substr(34, 2), 16).isZero();
        var result = new types_1.Balance(marginIsPositive ? margin : margin.negated(), positionIsPositive ? position : position.negated());
        result.rawValue = balance;
        return result;
    };
    Logs.prototype.parseFundingRate = function (fundingRate) {
        return this.parseIndex(fundingRate);
    };
    Logs.prototype.parseIndex = function (index) {
        var timestamp = new bignumber_js_1.default(index.substr(2, 30), 16);
        var isPositive = !new bignumber_js_1.default(index.substr(32, 2), 16).isZero();
        var value = new bignumber_js_1.default(index.substr(34, 32), 16);
        return {
            timestamp: timestamp,
            rawValue: index,
            baseValue: types_1.BaseValue.fromSolidity(value, isPositive),
        };
    };
    Logs.prototype.parseOrderFlags = function (flags) {
        var flagsNumber = new bignumber_js_1.default(flags, 16).mod(8).toNumber();
        return {
            rawValue: flags,
            isBuy: (flagsNumber & Constants_1.ORDER_FLAGS.IS_BUY) !== 0,
            isDecreaseOnly: (flagsNumber & Constants_1.ORDER_FLAGS.IS_DECREASE_ONLY) !== 0,
            isNegativeLimitFee: (flagsNumber & Constants_1.ORDER_FLAGS.IS_NEGATIVE_LIMIT_FEE) !== 0,
        };
    };
    return Logs;
}());
exports.Logs = Logs;
//# sourceMappingURL=Logs.js.map